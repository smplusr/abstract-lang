Programming language ideas : 

	Declarative
	Functional


Uses lambda calculus as its core, with declarative abstractions.
Needs to be heavily inspired by BASH or SHELLS in general : 


The language will be a collection of functions or collection of executable files
which will be mapped as instructions of the language.

There is no syntax, only function application.
This is where the functionnal paradigm comes in place.

Example of function application : 

	f(g(a)) -> f g a



//

No datastructure
Needs to be minimal

Static object addressing with names :
hello -> unique ptr

//




[INTERN] : 
Language needs : 

	- Internal pointer array
	- token system (array + pointer)
	- Lexer
	- Parser
	- Map function




[EXAMPLE] :

#EX1

hello is string hello_world_!

print hello
hello		<- same here


#EX2

four is 2 + 2
height is 4 + 4
height is 4 + 2 + 2


#EX3

bash is file /bin/sh
exec bash


#EX4

hello
<output> : hello is NULL




[SPECIAL KEYS]:

	- Space : delimiter
	- Return : Lexer -> Parser



[WARNINGS] :

	The parser may be invoked recursively




[ADDRESSING] :

+---+---+---+---+---+---+---+---+- -			- +---+---+---+---+---+---+---+---+- -			- +---+---+---+- -
| 1 | 2 | 3 | 4 | 5 | 6 | 7 |				  | 19| 1a| 1b| 1c| 1d| 1e| 1f|				  | 35| 36|
+---+---+---+---+---+---+---+- -		    - +---+---+---+---+---+---+---+---+- -		    - +---+---+---+- -
| a | b | c | d | e | f | 			      | x | y | z | aa| ba| ca| da|			      | za| ab|
+---+---+---+---+---+---+- -			- +---+---+---+---+---+---+---+---+- -			- +---+---+---+- -


1 character  -> char - offset
2 characters -> (char - offset) + ((char - offset) * dict_size)

(pos * dict_size) * (char - offset)

char 		is character
pos 		is character position in string				NEVER NULL
offset 		is difference between character 'a' and NULL		0 - 'a'			- 0x61
dict_size 	is number of character between 'a' and 'z' + 1		'z' - 'a' + 1		19





define store string hello store string test
define hello string test

read open string hello

define data hello string test




--- NEW VERSION, STANDARD AND SYNTAX HERE ---


Weird things happening when deleting a running stream :

	define Function string \
		remove var Function
		string " Should not print that? "
	\

	eval var Function

	print s var Function
	Should not print that? 


Could be a feature?

have	*ptr = '\0'	instead of	for (; *ptr; ptr++) *ptr = '\0'		in function delstr
